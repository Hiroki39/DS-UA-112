# ------------------------------------------------------------------------------
# E6-TotalKS.py
# Nov 22, 2020
# Hongyi Zheng
# Output the max difference or mean difference between two empirical cumulative
# density function generated by two sample distributions
# Accepts any 1D iterable object.
# ------------------------------------------------------------------------------

import numpy as np

writtenBy = "Hongyi Zheng"

# Could change this value to get more accurate result!
MEAN_DIFF_ASSESS_COUNT = 1000


def ecdf(sample):
    # find the unique values and their corresponding counts
    sorted_sample, counts = np.unique(sample, return_counts=True)

    # take the cumulative sum of the counts and divide by the sample size to
    # get the cumulative probabilities between 0 and 1
    proportions = np.cumsum(counts) / len(sample)

    return sorted_sample, proportions


def totalKS(data1, data2, flag):
    if flag not in (1, 2):
        raise ValueError("Invalid Flag")
    if len(data1) == 0 or len(data2) == 0:
        raise ValueError("Data Container Is Empty")

    sorted_unique1, ecdf1 = ecdf(data1)
    sorted_unique2, ecdf2 = ecdf(data2)

    # determine the interval and step for mean difference assess
    min_x = min(sorted_unique1[0], sorted_unique2[0])
    max_x = max(sorted_unique1[-1], sorted_unique2[-1])
    step = (max_x - min_x) / MEAN_DIFF_ASSESS_COUNT

    # merge-sort-like technique to get mean Dtotal or max difference

    # initialization
    cursor1 = cursor2 = 0
    max_diff = curr_diff = min(ecdf1[0], ecdf2[0])
    accumulated_diff = 0
    curr_assess = min_x + step / 2  # inital assess point

    # deal with the beginning portion of the data
    while curr_assess <= max(sorted_unique1[0], sorted_unique2[0]):
        accumulated_diff += curr_diff
        curr_assess += step

    # deal with the central portion of the data
    while cursor1 < len(ecdf1) and cursor2 < len(ecdf2):
        curr_diff = abs(ecdf1[cursor1] - ecdf2[cursor2])
        # check if curr_diff is max difference
        max_diff = max(max_diff, curr_diff)

        while curr_assess <= min(sorted_unique1[cursor1],
                                 sorted_unique2[cursor2]):
            # use curr_diff as an approximation of value at several assess
            # point that is close to current x value
            accumulated_diff += curr_diff
            curr_assess += step

        if sorted_unique1[cursor1] < sorted_unique2[cursor2]:
            cursor1 += 1
        else:
            cursor2 += 1

    # no need to check if the difference reaches maximum later because curr_diff
    # is monotonically decreasing in the following codes
    if flag == 1:
        return max_diff

    # deal with the ending portion of the data
    # The program will enter only one of following two loops
    while cursor1 < len(ecdf1):
        while curr_assess <= sorted_unique1[cursor1]:
            accumulated_diff += 1 - ecdf1[cursor1]
            curr_assess += step
        cursor1 += 1

    while cursor2 < len(ecdf2):
        while curr_assess <= sorted_unique2[cursor2]:
            accumulated_diff += 1 - ecdf2[cursor2]
            curr_assess += step
        cursor2 += 1

    return accumulated_diff / MEAN_DIFF_ASSESS_COUNT
